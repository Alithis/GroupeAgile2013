/*

Copyright (C) 2011 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license
*/
(function (n) { var t = {}, l, o, f, u, r, h, a, s, v; t.VERSION = "1.0.0", t.COMPILER_REVISION = 4, t.REVISION_CHANGES = { 1: "<= 1.0.rc.2", 2: "== 1.0.0-rc.3", 3: "== 1.0.0-rc.4", 4: ">= 1.0.0" }, t.helpers = {}, t.partials = {}; var i = Object.prototype.toString, e = "[object Function]", c = "[object Object]"; t.registerHelper = function (n, r, u) { if (i.call(n) === c) { if (u || r) throw new t.Exception("Arg not supported with multiple helpers"); t.Utils.extend(this.helpers, n) } else u && (r.not = u), this.helpers[n] = r }, t.registerPartial = function (n, r) { i.call(n) === c ? t.Utils.extend(this.partials, n) : this.partials[n] = r }, t.registerHelper("helperMissing", function (t) { if (arguments.length === 2) return n; throw new Error("Missing helper: '" + t + "'"); }), t.registerHelper("blockHelperMissing", function (n, r) { var u = r.inverse || function () { }, f = r.fn, o = i.call(n); return o === e && (n = n.call(this)), n === !0 ? f(this) : n === !1 || n == null ? u(this) : o === "[object Array]" ? n.length > 0 ? t.helpers.each(n, r) : u(this) : f(n) }), t.K = function () { }, t.createFrame = Object.create || function (n) { t.K.prototype = n; var i = new t.K; return t.K.prototype = null, i }, t.logger = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, level: 3, methodMap: { 0: "debug", 1: "info", 2: "warn", 3: "error" }, log: function (n, i) { if (t.logger.level <= n) { var r = t.logger.methodMap[n]; typeof console != "undefined" && console[r] && console[r].call(console, i) } } }, t.log = function (n, i) { t.logger.log(n, i) }, t.registerHelper("each", function (n, r) { var h = r.fn, l = r.inverse, f = 0, o = "", u, a = i.call(n), c, s; if (a === e && (n = n.call(this)), r.data && (u = t.createFrame(r.data)), n && typeof n == "object") if (n instanceof Array) for (c = n.length; f < c; f++) u && (u.index = f), o = o + h(n[f], { data: u }); else for (s in n) n.hasOwnProperty(s) && (u && (u.key = s), o = o + h(n[s], { data: u }), f++); return f === 0 && (o = l(this)), o }), t.registerHelper("if", function (n, r) { var u = i.call(n); return u === e && (n = n.call(this)), !n || t.Utils.isEmpty(n) ? r.inverse(this) : r.fn(this) }), t.registerHelper("unless", function (n, i) { return t.helpers["if"].call(this, n, { fn: i.inverse, inverse: i.fn }) }), t.registerHelper("with", function (n, r) { var u = i.call(n); return u === e && (n = n.call(this)), t.Utils.isEmpty(n) ? void 0 : r.fn(n) }), t.registerHelper("log", function (n, i) { var r = i.data && i.data.level != null ? parseInt(i.data.level, 10) : 1; t.log(r, n) }), l = function () { function t() { this.yy = {} } var n = { trace: function () { }, yy: {}, symbols_: { error: 2, root: 3, program: 4, EOF: 5, simpleInverse: 6, statements: 7, statement: 8, openInverse: 9, closeBlock: 10, openBlock: 11, mustache: 12, partial: 13, CONTENT: 14, COMMENT: 15, OPEN_BLOCK: 16, inMustache: 17, CLOSE: 18, OPEN_INVERSE: 19, OPEN_ENDBLOCK: 20, path: 21, OPEN: 22, OPEN_UNESCAPED: 23, CLOSE_UNESCAPED: 24, OPEN_PARTIAL: 25, partialName: 26, params: 27, hash: 28, dataName: 29, param: 30, STRING: 31, INTEGER: 32, BOOLEAN: 33, hashSegments: 34, hashSegment: 35, ID: 36, EQUALS: 37, DATA: 38, pathSegments: 39, SEP: 40, $accept: 0, $end: 1 }, terminals_: { 2: "error", 5: "EOF", 14: "CONTENT", 15: "COMMENT", 16: "OPEN_BLOCK", 18: "CLOSE", 19: "OPEN_INVERSE", 20: "OPEN_ENDBLOCK", 22: "OPEN", 23: "OPEN_UNESCAPED", 24: "CLOSE_UNESCAPED", 25: "OPEN_PARTIAL", 31: "STRING", 32: "INTEGER", 33: "BOOLEAN", 36: "ID", 37: "EQUALS", 38: "DATA", 40: "SEP" }, productions_: [0, [3, 2], [4, 2], [4, 3], [4, 2], [4, 1], [4, 1], [4, 0], [7, 1], [7, 2], [8, 3], [8, 3], [8, 1], [8, 1], [8, 1], [8, 1], [11, 3], [9, 3], [10, 3], [12, 3], [12, 3], [13, 3], [13, 4], [6, 2], [17, 3], [17, 2], [17, 2], [17, 1], [17, 1], [27, 2], [27, 1], [30, 1], [30, 1], [30, 1], [30, 1], [30, 1], [28, 1], [34, 2], [34, 1], [35, 3], [35, 3], [35, 3], [35, 3], [35, 3], [26, 1], [26, 1], [26, 1], [29, 2], [21, 1], [39, 3], [39, 1]], performAction: function (n, t, i, r, u, f) { var e = f.length - 1; switch (u) { case 1: return f[e - 1]; case 2: this.$ = new r.ProgramNode([], f[e]); break; case 3: this.$ = new r.ProgramNode(f[e - 2], f[e]); break; case 4: this.$ = new r.ProgramNode(f[e - 1], []); break; case 5: this.$ = new r.ProgramNode(f[e]); break; case 6: this.$ = new r.ProgramNode([], []); break; case 7: this.$ = new r.ProgramNode([]); break; case 8: this.$ = [f[e]]; break; case 9: f[e - 1].push(f[e]), this.$ = f[e - 1]; break; case 10: this.$ = new r.BlockNode(f[e - 2], f[e - 1].inverse, f[e - 1], f[e]); break; case 11: this.$ = new r.BlockNode(f[e - 2], f[e - 1], f[e - 1].inverse, f[e]); break; case 12: this.$ = f[e]; break; case 13: this.$ = f[e]; break; case 14: this.$ = new r.ContentNode(f[e]); break; case 15: this.$ = new r.CommentNode(f[e]); break; case 16: this.$ = new r.MustacheNode(f[e - 1][0], f[e - 1][1]); break; case 17: this.$ = new r.MustacheNode(f[e - 1][0], f[e - 1][1]); break; case 18: this.$ = f[e - 1]; break; case 19: this.$ = new r.MustacheNode(f[e - 1][0], f[e - 1][1], f[e - 2][2] === "&"); break; case 20: this.$ = new r.MustacheNode(f[e - 1][0], f[e - 1][1], !0); break; case 21: this.$ = new r.PartialNode(f[e - 1]); break; case 22: this.$ = new r.PartialNode(f[e - 2], f[e - 1]); break; case 24: this.$ = [[f[e - 2]].concat(f[e - 1]), f[e]]; break; case 25: this.$ = [[f[e - 1]].concat(f[e]), null]; break; case 26: this.$ = [[f[e - 1]], f[e]]; break; case 27: this.$ = [[f[e]], null]; break; case 28: this.$ = [[f[e]], null]; break; case 29: f[e - 1].push(f[e]), this.$ = f[e - 1]; break; case 30: this.$ = [f[e]]; break; case 31: this.$ = f[e]; break; case 32: this.$ = new r.StringNode(f[e]); break; case 33: this.$ = new r.IntegerNode(f[e]); break; case 34: this.$ = new r.BooleanNode(f[e]); break; case 35: this.$ = f[e]; break; case 36: this.$ = new r.HashNode(f[e]); break; case 37: f[e - 1].push(f[e]), this.$ = f[e - 1]; break; case 38: this.$ = [f[e]]; break; case 39: this.$ = [f[e - 2], f[e]]; break; case 40: this.$ = [f[e - 2], new r.StringNode(f[e])]; break; case 41: this.$ = [f[e - 2], new r.IntegerNode(f[e])]; break; case 42: this.$ = [f[e - 2], new r.BooleanNode(f[e])]; break; case 43: this.$ = [f[e - 2], f[e]]; break; case 44: this.$ = new r.PartialNameNode(f[e]); break; case 45: this.$ = new r.PartialNameNode(new r.StringNode(f[e])); break; case 46: this.$ = new r.PartialNameNode(new r.IntegerNode(f[e])); break; case 47: this.$ = new r.DataNode(f[e]); break; case 48: this.$ = new r.IdNode(f[e]); break; case 49: f[e - 2].push({ part: f[e], separator: f[e - 1] }), this.$ = f[e - 2]; break; case 50: this.$ = [{ part: f[e] }] } }, table: [{ 3: 1, 4: 2, 5: [2, 7], 6: 3, 7: 4, 8: 6, 9: 7, 11: 8, 12: 9, 13: 10, 14: [1, 11], 15: [1, 12], 16: [1, 13], 19: [1, 5], 22: [1, 14], 23: [1, 15], 25: [1, 16] }, { 1: [3] }, { 5: [1, 17] }, { 5: [2, 6], 7: 18, 8: 6, 9: 7, 11: 8, 12: 9, 13: 10, 14: [1, 11], 15: [1, 12], 16: [1, 13], 19: [1, 19], 20: [2, 6], 22: [1, 14], 23: [1, 15], 25: [1, 16] }, { 5: [2, 5], 6: 20, 8: 21, 9: 7, 11: 8, 12: 9, 13: 10, 14: [1, 11], 15: [1, 12], 16: [1, 13], 19: [1, 5], 20: [2, 5], 22: [1, 14], 23: [1, 15], 25: [1, 16] }, { 17: 23, 18: [1, 22], 21: 24, 29: 25, 36: [1, 28], 38: [1, 27], 39: 26 }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 16: [2, 8], 19: [2, 8], 20: [2, 8], 22: [2, 8], 23: [2, 8], 25: [2, 8] }, { 4: 29, 6: 3, 7: 4, 8: 6, 9: 7, 11: 8, 12: 9, 13: 10, 14: [1, 11], 15: [1, 12], 16: [1, 13], 19: [1, 5], 20: [2, 7], 22: [1, 14], 23: [1, 15], 25: [1, 16] }, { 4: 30, 6: 3, 7: 4, 8: 6, 9: 7, 11: 8, 12: 9, 13: 10, 14: [1, 11], 15: [1, 12], 16: [1, 13], 19: [1, 5], 20: [2, 7], 22: [1, 14], 23: [1, 15], 25: [1, 16] }, { 5: [2, 12], 14: [2, 12], 15: [2, 12], 16: [2, 12], 19: [2, 12], 20: [2, 12], 22: [2, 12], 23: [2, 12], 25: [2, 12] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 16: [2, 13], 19: [2, 13], 20: [2, 13], 22: [2, 13], 23: [2, 13], 25: [2, 13] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 16: [2, 14], 19: [2, 14], 20: [2, 14], 22: [2, 14], 23: [2, 14], 25: [2, 14] }, { 5: [2, 15], 14: [2, 15], 15: [2, 15], 16: [2, 15], 19: [2, 15], 20: [2, 15], 22: [2, 15], 23: [2, 15], 25: [2, 15] }, { 17: 31, 21: 24, 29: 25, 36: [1, 28], 38: [1, 27], 39: 26 }, { 17: 32, 21: 24, 29: 25, 36: [1, 28], 38: [1, 27], 39: 26 }, { 17: 33, 21: 24, 29: 25, 36: [1, 28], 38: [1, 27], 39: 26 }, { 21: 35, 26: 34, 31: [1, 36], 32: [1, 37], 36: [1, 28], 39: 26 }, { 1: [2, 1] }, { 5: [2, 2], 8: 21, 9: 7, 11: 8, 12: 9, 13: 10, 14: [1, 11], 15: [1, 12], 16: [1, 13], 19: [1, 19], 20: [2, 2], 22: [1, 14], 23: [1, 15], 25: [1, 16] }, { 17: 23, 21: 24, 29: 25, 36: [1, 28], 38: [1, 27], 39: 26 }, { 5: [2, 4], 7: 38, 8: 6, 9: 7, 11: 8, 12: 9, 13: 10, 14: [1, 11], 15: [1, 12], 16: [1, 13], 19: [1, 19], 20: [2, 4], 22: [1, 14], 23: [1, 15], 25: [1, 16] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 16: [2, 9], 19: [2, 9], 20: [2, 9], 22: [2, 9], 23: [2, 9], 25: [2, 9] }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 16: [2, 23], 19: [2, 23], 20: [2, 23], 22: [2, 23], 23: [2, 23], 25: [2, 23] }, { 18: [1, 39] }, { 18: [2, 27], 21: 44, 24: [2, 27], 27: 40, 28: 41, 29: 48, 30: 42, 31: [1, 45], 32: [1, 46], 33: [1, 47], 34: 43, 35: 49, 36: [1, 50], 38: [1, 27], 39: 26 }, { 18: [2, 28], 24: [2, 28] }, { 18: [2, 48], 24: [2, 48], 31: [2, 48], 32: [2, 48], 33: [2, 48], 36: [2, 48], 38: [2, 48], 40: [1, 51] }, { 21: 52, 36: [1, 28], 39: 26 }, { 18: [2, 50], 24: [2, 50], 31: [2, 50], 32: [2, 50], 33: [2, 50], 36: [2, 50], 38: [2, 50], 40: [2, 50] }, { 10: 53, 20: [1, 54] }, { 10: 55, 20: [1, 54] }, { 18: [1, 56] }, { 18: [1, 57] }, { 24: [1, 58] }, { 18: [1, 59], 21: 60, 36: [1, 28], 39: 26 }, { 18: [2, 44], 36: [2, 44] }, { 18: [2, 45], 36: [2, 45] }, { 18: [2, 46], 36: [2, 46] }, { 5: [2, 3], 8: 21, 9: 7, 11: 8, 12: 9, 13: 10, 14: [1, 11], 15: [1, 12], 16: [1, 13], 19: [1, 19], 20: [2, 3], 22: [1, 14], 23: [1, 15], 25: [1, 16] }, { 14: [2, 17], 15: [2, 17], 16: [2, 17], 19: [2, 17], 20: [2, 17], 22: [2, 17], 23: [2, 17], 25: [2, 17] }, { 18: [2, 25], 21: 44, 24: [2, 25], 28: 61, 29: 48, 30: 62, 31: [1, 45], 32: [1, 46], 33: [1, 47], 34: 43, 35: 49, 36: [1, 50], 38: [1, 27], 39: 26 }, { 18: [2, 26], 24: [2, 26] }, { 18: [2, 30], 24: [2, 30], 31: [2, 30], 32: [2, 30], 33: [2, 30], 36: [2, 30], 38: [2, 30] }, { 18: [2, 36], 24: [2, 36], 35: 63, 36: [1, 64] }, { 18: [2, 31], 24: [2, 31], 31: [2, 31], 32: [2, 31], 33: [2, 31], 36: [2, 31], 38: [2, 31] }, { 18: [2, 32], 24: [2, 32], 31: [2, 32], 32: [2, 32], 33: [2, 32], 36: [2, 32], 38: [2, 32] }, { 18: [2, 33], 24: [2, 33], 31: [2, 33], 32: [2, 33], 33: [2, 33], 36: [2, 33], 38: [2, 33] }, { 18: [2, 34], 24: [2, 34], 31: [2, 34], 32: [2, 34], 33: [2, 34], 36: [2, 34], 38: [2, 34] }, { 18: [2, 35], 24: [2, 35], 31: [2, 35], 32: [2, 35], 33: [2, 35], 36: [2, 35], 38: [2, 35] }, { 18: [2, 38], 24: [2, 38], 36: [2, 38] }, { 18: [2, 50], 24: [2, 50], 31: [2, 50], 32: [2, 50], 33: [2, 50], 36: [2, 50], 37: [1, 65], 38: [2, 50], 40: [2, 50] }, { 36: [1, 66] }, { 18: [2, 47], 24: [2, 47], 31: [2, 47], 32: [2, 47], 33: [2, 47], 36: [2, 47], 38: [2, 47] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 16: [2, 10], 19: [2, 10], 20: [2, 10], 22: [2, 10], 23: [2, 10], 25: [2, 10] }, { 21: 67, 36: [1, 28], 39: 26 }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 16: [2, 11], 19: [2, 11], 20: [2, 11], 22: [2, 11], 23: [2, 11], 25: [2, 11] }, { 14: [2, 16], 15: [2, 16], 16: [2, 16], 19: [2, 16], 20: [2, 16], 22: [2, 16], 23: [2, 16], 25: [2, 16] }, { 5: [2, 19], 14: [2, 19], 15: [2, 19], 16: [2, 19], 19: [2, 19], 20: [2, 19], 22: [2, 19], 23: [2, 19], 25: [2, 19] }, { 5: [2, 20], 14: [2, 20], 15: [2, 20], 16: [2, 20], 19: [2, 20], 20: [2, 20], 22: [2, 20], 23: [2, 20], 25: [2, 20] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 16: [2, 21], 19: [2, 21], 20: [2, 21], 22: [2, 21], 23: [2, 21], 25: [2, 21] }, { 18: [1, 68] }, { 18: [2, 24], 24: [2, 24] }, { 18: [2, 29], 24: [2, 29], 31: [2, 29], 32: [2, 29], 33: [2, 29], 36: [2, 29], 38: [2, 29] }, { 18: [2, 37], 24: [2, 37], 36: [2, 37] }, { 37: [1, 65] }, { 21: 69, 29: 73, 31: [1, 70], 32: [1, 71], 33: [1, 72], 36: [1, 28], 38: [1, 27], 39: 26 }, { 18: [2, 49], 24: [2, 49], 31: [2, 49], 32: [2, 49], 33: [2, 49], 36: [2, 49], 38: [2, 49], 40: [2, 49] }, { 18: [1, 74] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 16: [2, 22], 19: [2, 22], 20: [2, 22], 22: [2, 22], 23: [2, 22], 25: [2, 22] }, { 18: [2, 39], 24: [2, 39], 36: [2, 39] }, { 18: [2, 40], 24: [2, 40], 36: [2, 40] }, { 18: [2, 41], 24: [2, 41], 36: [2, 41] }, { 18: [2, 42], 24: [2, 42], 36: [2, 42] }, { 18: [2, 43], 24: [2, 43], 36: [2, 43] }, { 5: [2, 18], 14: [2, 18], 15: [2, 18], 16: [2, 18], 19: [2, 18], 20: [2, 18], 22: [2, 18], 23: [2, 18], 25: [2, 18] }], defaultActions: { 17: [2, 1] }, parseError: function (n) { throw new Error(n); }, parse: function (n) { function it() { var n; return n = k.lexer.lex() || 1, typeof n != "number" && (n = k.symbols_[n] || n), n } var k = this, r = [0], f = [null], t = [], h = this.table, d = "", c = 0, g = 0, y = 0, l, nt, i, p, o, u, w, s, a, e, tt, v, b; for (this.lexer.setInput(n), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, typeof this.lexer.yylloc == "undefined" && (this.lexer.yylloc = {}), l = this.lexer.yylloc, t.push(l), nt = this.lexer.options && this.lexer.options.ranges, typeof this.yy.parseError == "function" && (this.parseError = this.yy.parseError), s = {}; ;) { if (o = r[r.length - 1], this.defaultActions[o] ? u = this.defaultActions[o] : ((i === null || typeof i == "undefined") && (i = it()), u = h[o] && h[o][i]), (typeof u == "undefined" || !u.length || !u[0]) && (b = "", !y)) { v = []; for (a in h[o]) this.terminals_[a] && a > 2 && v.push("'" + this.terminals_[a] + "'"); b = this.lexer.showPosition ? "Parse error on line " + (c + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + v.join(", ") + ", got '" + (this.terminals_[i] || i) + "'" : "Parse error on line " + (c + 1) + ": Unexpected " + (i == 1 ? "end of input" : "'" + (this.terminals_[i] || i) + "'"), this.parseError(b, { text: this.lexer.match, token: this.terminals_[i] || i, line: this.lexer.yylineno, loc: l, expected: v }) } if (u[0] instanceof Array && u.length > 1) throw new Error("Parse Error: multiple actions possible at state: " + o + ", token: " + i); switch (u[0]) { case 1: r.push(i), f.push(this.lexer.yytext), t.push(this.lexer.yylloc), r.push(u[1]), i = null, p ? (i = p, p = null) : (g = this.lexer.yyleng, d = this.lexer.yytext, c = this.lexer.yylineno, l = this.lexer.yylloc, y > 0 && y--); break; case 2: if (e = this.productions_[u[1]][1], s.$ = f[f.length - e], s._$ = { first_line: t[t.length - (e || 1)].first_line, last_line: t[t.length - 1].last_line, first_column: t[t.length - (e || 1)].first_column, last_column: t[t.length - 1].last_column }, nt && (s._$.range = [t[t.length - (e || 1)].range[0], t[t.length - 1].range[1]]), w = this.performAction.call(s, d, g, c, this.yy, u[1], f, t), typeof w != "undefined") return w; e && (r = r.slice(0, -2 * e), f = f.slice(0, -1 * e), t = t.slice(0, -1 * e)), r.push(this.productions_[u[1]][0]), f.push(s.$), t.push(s._$), tt = h[r[r.length - 2]][r[r.length - 1]], r.push(tt); break; case 3: return !0 } } return !0 } }, i = function () { var n = { EOF: 1, parseError: function (n, t) { if (this.yy.parser) this.yy.parser.parseError(n, t); else throw new Error(n); }, setInput: function (n) { return this._input = n, this._more = this._less = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this }, input: function () { var n = this._input[0], t; return this.yytext += n, this.yyleng++, this.offset++, this.match += n, this.matched += n, t = n.match(/(?:\r\n?|\n).*/g), t ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), n }, unput: function (n) { var i = n.length, t = n.split(/(?:\r\n?|\n)/g), r, u; return this._input = n + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - i - 1), this.offset -= i, r = this.match.split(/(?:\r\n?|\n)/g), this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), t.length - 1 && (this.yylineno -= t.length - 1), u = this.yylloc.range, this.yylloc = { first_line: this.yylloc.first_line, last_line: this.yylineno + 1, first_column: this.yylloc.first_column, last_column: t ? (t.length === r.length ? this.yylloc.first_column : 0) + r[r.length - t.length].length - t[0].length : this.yylloc.first_column - i }, this.options.ranges && (this.yylloc.range = [u[0], u[0] + this.yyleng - i]), this }, more: function () { return this._more = !0, this }, less: function (n) { this.unput(this.match.slice(n)) }, pastInput: function () { var n = this.matched.substr(0, this.matched.length - this.match.length); return (n.length > 20 ? "..." : "") + n.substr(-20).replace(/\n/g, "") }, upcomingInput: function () { var n = this.match; return n.length < 20 && (n += this._input.substr(0, 20 - n.length)), (n.substr(0, 20) + (n.length > 20 ? "..." : "")).replace(/\n/g, "") }, showPosition: function () { var n = this.pastInput(), t = new Array(n.length + 1).join("-"); return n + this.upcomingInput() + "\n" + t + "^" }, next: function () { var f, n, r, e, t, u, i; if (this.done) return this.EOF; for (this._input || (this.done = !0), this._more || (this.yytext = "", this.match = ""), u = this._currentRules(), i = 0; i < u.length; i++) if (r = this._input.match(this.rules[u[i]]), r && (!n || r[0].length > n[0].length) && (n = r, e = i, !this.options.flex)) break; return n ? (t = n[0].match(/(?:\r\n?|\n).*/g), t && (this.yylineno += t.length), this.yylloc = { first_line: this.yylloc.last_line, last_line: this.yylineno + 1, first_column: this.yylloc.last_column, last_column: t ? t[t.length - 1].length - t[t.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + n[0].length }, this.yytext += n[0], this.match += n[0], this.matches = n, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._input = this._input.slice(n[0].length), this.matched += n[0], f = this.performAction.call(this, this.yy, this, u[e], this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), f) ? f : void 0 : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno }) }, lex: function () { var n = this.next(); return typeof n != "undefined" ? n : this.lex() }, begin: function (n) { this.conditionStack.push(n) }, popState: function () { return this.conditionStack.pop() }, _currentRules: function () { return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules }, topState: function () { return this.conditionStack[this.conditionStack.length - 2] }, pushState: function (n) { this.begin(n) } }; return n.options = {}, n.performAction = function (n, t, i, r) { var u = r; switch (i) { case 0: return t.yytext = "\\", 14; case 1: if (t.yytext.slice(-1) !== "\\" && this.begin("mu"), t.yytext.slice(-1) === "\\" && (t.yytext = t.yytext.substr(0, t.yyleng - 1), this.begin("emu")), t.yytext) return 14; break; case 2: return 14; case 3: return t.yytext.slice(-1) !== "\\" && this.popState(), t.yytext.slice(-1) === "\\" && (t.yytext = t.yytext.substr(0, t.yyleng - 1)), 14; case 4: return t.yytext = t.yytext.substr(0, t.yyleng - 4), this.popState(), 15; case 5: return 25; case 6: return 16; case 7: return 20; case 8: return 19; case 9: return 19; case 10: return 23; case 11: return 22; case 12: this.popState(), this.begin("com"); break; case 13: return t.yytext = t.yytext.substr(3, t.yyleng - 5), this.popState(), 15; case 14: return 22; case 15: return 37; case 16: return 36; case 17: return 36; case 18: return 40; case 20: return this.popState(), 24; case 21: return this.popState(), 18; case 22: return t.yytext = t.yytext.substr(1, t.yyleng - 2).replace(/\\"/g, '"'), 31; case 23: return t.yytext = t.yytext.substr(1, t.yyleng - 2).replace(/\\'/g, "'"), 31; case 24: return 38; case 25: return 33; case 26: return 33; case 27: return 32; case 28: return 36; case 29: return t.yytext = t.yytext.substr(1, t.yyleng - 2), 36; case 30: return "INVALID"; case 31: return 5 } }, n.rules = [/^(?:\\\\(?=(\{\{)))/, /^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|$)))/, /^(?:[\s\S]*?--\}\})/, /^(?:\{\{>)/, /^(?:\{\{#)/, /^(?:\{\{\/)/, /^(?:\{\{\^)/, /^(?:\{\{\s*else\b)/, /^(?:\{\{\{)/, /^(?:\{\{&)/, /^(?:\{\{!--)/, /^(?:\{\{![\s\S]*?\}\})/, /^(?:\{\{)/, /^(?:=)/, /^(?:\.(?=[}\/ ]))/, /^(?:\.\.)/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}\}\})/, /^(?:\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=[}\s]))/, /^(?:false(?=[}\s]))/, /^(?:-?[0-9]+(?=[}\s]))/, /^(?:[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.]))/, /^(?:\[[^\]]*\])/, /^(?:.)/, /^(?:$)/], n.conditions = { mu: { rules: [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31], inclusive: !1 }, emu: { rules: [3], inclusive: !1 }, com: { rules: [4], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 31], inclusive: !0 } }, n }(); return n.lexer = i, t.prototype = n, n.Parser = t, new t }(), t.Parser = l, t.parse = function (n) { return n.constructor === t.AST.ProgramNode ? n : (t.Parser.yy = t.AST, t.Parser.parse(n)) }, t.AST = {}, t.AST.ProgramNode = function (n, i) { this.type = "program", this.statements = n, i && (this.inverse = new t.AST.ProgramNode(i)) }, t.AST.MustacheNode = function (n, t, i) { this.type = "mustache", this.escaped = !i, this.hash = t; var r = this.id = n[0], u = this.params = n.slice(1), f = this.eligibleHelper = r.isSimple; this.isHelper = f && (u.length || t) }, t.AST.PartialNode = function (n, t) { this.type = "partial", this.partialName = n, this.context = t }, t.AST.BlockNode = function (n, i, r, u) { if (n.id.original !== u.original) throw new t.Exception(n.id.original + " doesn't match " + u.original); this.type = "block", this.mustache = n, this.program = i, this.inverse = r, this.inverse && !this.program && (this.isInverse = !0) }, t.AST.ContentNode = function (n) { this.type = "content", this.string = n }, t.AST.HashNode = function (n) { this.type = "hash", this.pairs = n }, t.AST.IdNode = function (n) { var r, o, i; this.type = "ID"; var f = "", u = [], e = 0; for (r = 0, o = n.length; r < o; r++) if (i = n[r].part, f += (n[r].separator || "") + i, i === ".." || i === "." || i === "this") if (u.length > 0) throw new t.Exception("Invalid path: " + f); else i === ".." ? e++ : this.isScoped = !0; else u.push(i); this.original = f, this.parts = u, this.string = u.join("."), this.depth = e, this.isSimple = n.length === 1 && !this.isScoped && e === 0, this.stringModeValue = this.string }, t.AST.PartialNameNode = function (n) { this.type = "PARTIAL_NAME", this.name = n.original }, t.AST.DataNode = function (n) { this.type = "DATA", this.id = n }, t.AST.StringNode = function (n) { this.type = "STRING", this.original = this.string = this.stringModeValue = n }, t.AST.IntegerNode = function (n) { this.type = "INTEGER", this.original = this.integer = n, this.stringModeValue = Number(n) }, t.AST.BooleanNode = function (n) { this.type = "BOOLEAN", this.bool = n, this.stringModeValue = n === "true" }, t.AST.CommentNode = function (n) { this.type = "comment", this.comment = n }, o = ["description", "fileName", "lineNumber", "message", "name", "number", "stack"], t.Exception = function () { for (var t = Error.prototype.constructor.apply(this, arguments), n = 0; n < o.length; n++) this[o[n]] = t[o[n]] }, t.Exception.prototype = new Error, t.SafeString = function (n) { this.string = n }, t.SafeString.prototype.toString = function () { return this.string.toString() }; var y = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;" }, p = /[&<>"'`]/g, w = /[&<>"'`]/, b = function (n) { return y[n] || "&amp;" }; for (t.Utils = { extend: function (n, t) { for (var i in t) t.hasOwnProperty(i) && (n[i] = t[i]) }, escapeExpression: function (n) { return n instanceof t.SafeString ? n.toString() : n == null || n === !1 ? "" : (n = n.toString(), !w.test(n)) ? n : n.replace(p, b) }, isEmpty: function (n) { return n || n === 0 ? i.call(n) === "[object Array]" && n.length === 0 ? !0 : !1 : !0 } }, f = t.Compiler = function () { }, f.prototype = { compiler: f, disassemble: function () { for (var e = this.opcodes, n, u = [], f, t, r, i = 0, o = e.length; i < o; i++) if (n = e[i], n.opcode === "DECLARE") u.push("DECLARE " + n.name + "=" + n.value); else { for (f = [], r = 0; r < n.args.length; r++) t = n.args[r], typeof t == "string" && (t = '"' + t.replace("\n", "\\n") + '"'), f.push(t); u.push(n.opcode + " " + f.join(" ")) } return u.join("\n") }, equals: function (n) { var i = this.opcodes.length, t, r, f, u; if (n.opcodes.length !== i) return !1; for (t = 0; t < i; t++) { if (r = this.opcodes[t], f = n.opcodes[t], r.opcode !== f.opcode || r.args.length !== f.args.length) return !1; for (u = 0; u < r.args.length; u++) if (r.args[u] !== f.args[u]) return !1 } if (i = this.children.length, n.children.length !== i) return !1; for (t = 0; t < i; t++) if (!this.children[t].equals(n.children[t])) return !1; return !0 }, guid: 0, compile: function (n, t) { var i, r; if (this.children = [], this.depths = { list: [] }, this.options = t, i = this.options.knownHelpers, this.options.knownHelpers = { helperMissing: !0, blockHelperMissing: !0, each: !0, "if": !0, unless: !0, "with": !0, log: !0 }, i) for (r in i) this.options.knownHelpers[r] = i[r]; return this.program(n) }, accept: function (n) { return this[n.type](n) }, program: function (n) { var u = n.statements, i, t, r; for (this.opcodes = [], t = 0, r = u.length; t < r; t++) i = u[t], this[i.type](i); return this.isSimple = r === 1, this.depths.list = this.depths.list.sort(function (n, t) { return n - t }), this }, compileProgram: function (n) { var t = (new this.compiler).compile(n, this.options), u = this.guid++, r, i, f; for (this.usePartial = this.usePartial || t.usePartial, this.children[u] = t, i = 0, f = t.depths.list.length; i < f; i++) if (r = t.depths.list[i], r < 2) continue; else this.addDepth(r - 1); return u }, block: function (n) { var r = n.mustache, t = n.program, i = n.inverse, u; t && (t = this.compileProgram(t)), i && (i = this.compileProgram(i)), u = this.classifyMustache(r), u === "helper" ? this.helperMustache(r, t, i) : u === "simple" ? (this.simpleMustache(r), this.opcode("pushProgram", t), this.opcode("pushProgram", i), this.opcode("emptyHash"), this.opcode("blockValue")) : (this.ambiguousMustache(r, t, i), this.opcode("pushProgram", t), this.opcode("pushProgram", i), this.opcode("emptyHash"), this.opcode("ambiguousBlockValue")), this.opcode("append") }, hash: function (n) { var u = n.pairs, r, t, i, f; for (this.opcode("pushHash"), i = 0, f = u.length; i < f; i++) r = u[i], t = r[1], this.options.stringParams ? (t.depth && this.addDepth(t.depth), this.opcode("getContext", t.depth || 0), this.opcode("pushStringParam", t.stringModeValue, t.type)) : this.accept(t), this.opcode("assignToHash", r[0]); this.opcode("popHash") }, partial: function (n) { var t = n.partialName; this.usePartial = !0, n.context ? this.ID(n.context) : this.opcode("push", "depth0"), this.opcode("invokePartial", t.name), this.opcode("append") }, content: function (n) { this.opcode("appendContent", n.string) }, mustache: function (n) { var i = this.options, t = this.classifyMustache(n); t === "simple" ? this.simpleMustache(n) : t === "helper" ? this.helperMustache(n) : this.ambiguousMustache(n), n.escaped && !i.noEscape ? this.opcode("appendEscaped") : this.opcode("append") }, ambiguousMustache: function (n, t, i) { var r = n.id, u = r.parts[0], f = t != null || i != null; this.opcode("getContext", r.depth), this.opcode("pushProgram", t), this.opcode("pushProgram", i), this.opcode("invokeAmbiguous", u, f) }, simpleMustache: function (n) { var t = n.id; t.type === "DATA" ? this.DATA(t) : t.parts.length ? this.ID(t) : (this.addDepth(t.depth), this.opcode("getContext", t.depth), this.opcode("pushContext")), this.opcode("resolvePossibleLambda") }, helperMustache: function (n, t, i) { var u = this.setupFullMustacheParams(n, t, i), r = n.id.parts[0]; if (this.options.knownHelpers[r]) this.opcode("invokeKnownHelper", u.length, r); else if (this.options.knownHelpersOnly) throw new Error("You specified knownHelpersOnly, but used the unknown helper " + r); else this.opcode("invokeHelper", u.length, r) }, ID: function (n) { var i, t, r; for (this.addDepth(n.depth), this.opcode("getContext", n.depth), i = n.parts[0], i ? this.opcode("lookupOnContext", n.parts[0]) : this.opcode("pushContext"), t = 1, r = n.parts.length; t < r; t++) this.opcode("lookup", n.parts[t]) }, DATA: function (n) { var r, i, u; if (this.options.data = !0, n.id.isScoped || n.id.depth) throw new t.Exception("Scoped data references are not supported: " + n.original); for (this.opcode("lookupData"), r = n.id.parts, i = 0, u = r.length; i < u; i++) this.opcode("lookup", r[i]) }, STRING: function (n) { this.opcode("pushString", n.string) }, INTEGER: function (n) { this.opcode("pushLiteral", n.integer) }, BOOLEAN: function (n) { this.opcode("pushLiteral", n.bool) }, comment: function () { }, opcode: function (n) { this.opcodes.push({ opcode: n, args: [].slice.call(arguments, 1) }) }, declare: function (n, t) { this.opcodes.push({ opcode: "DECLARE", name: n, value: t }) }, addDepth: function (n) { if (isNaN(n)) throw new Error("EWOT"); n !== 0 && (this.depths[n] || (this.depths[n] = !0, this.depths.list.push(n))) }, classifyMustache: function (n) { var t = n.isHelper, i = n.eligibleHelper, r = this.options, u; return i && !t && (u = n.id.parts[0], r.knownHelpers[u] ? t = !0 : r.knownHelpersOnly && (i = !1)), t ? "helper" : i ? "ambiguous" : "simple" }, pushParams: function (n) { for (var i = n.length, t; i--;) t = n[i], this.options.stringParams ? (t.depth && this.addDepth(t.depth), this.opcode("getContext", t.depth || 0), this.opcode("pushStringParam", t.stringModeValue, t.type)) : this[t.type](t) }, setupMustacheParams: function (n) { var t = n.params; return this.pushParams(t), n.hash ? this.hash(n.hash) : this.opcode("emptyHash"), t }, setupFullMustacheParams: function (n, t, i) { var r = n.params; return this.pushParams(r), this.opcode("pushProgram", t), this.opcode("pushProgram", i), n.hash ? this.hash(n.hash) : this.opcode("emptyHash"), r } }, t.precompile = function (n, i) { if (n == null || typeof n != "string" && n.constructor !== t.AST.ProgramNode) throw new t.Exception("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + n); i = i || {}, "data" in i || (i.data = !0); var r = t.parse(n), u = (new f).compile(r, i); return (new t.JavaScriptCompiler).compile(u, i) }, t.compile = function (i, r) { function e() { var u = t.parse(i), e = (new f).compile(u, r), o = (new t.JavaScriptCompiler).compile(e, r, n, !0); return t.template(o) } if (i == null || typeof i != "string" && i.constructor !== t.AST.ProgramNode) throw new t.Exception("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + i); r = r || {}, "data" in r || (r.data = !0); var u; return function (n, t) { return u || (u = e()), u.call(this, n, t) } }, u = function (n) { this.value = n }, r = t.JavaScriptCompiler = function () { }, r.prototype = { nameLookup: function (n, t) { return /^[0-9]+$/.test(t) ? n + "[" + t + "]" : r.isValidJavaScriptVariableName(t) ? n + "." + t : n + "['" + t + "']" }, appendToBuffer: function (n) { return this.environment.isSimple ? "return " + n + ";" : { appendToBuffer: !0, content: n, toString: function () { return "buffer += " + n + ";" } } }, initializeBuffer: function () { return this.quotedString("") }, namespace: "Handlebars", compile: function (n, i, r, u) { var e, f, o; for (this.environment = n, this.options = i || {}, t.log(t.logger.DEBUG, this.environment.disassemble() + "\n\n"), this.name = this.environment.name, this.isChild = !!r, this.context = r || { programs: [], environments: [], aliases: {} }, this.preamble(), this.stackSlot = 0, this.stackVars = [], this.registers = { list: [] }, this.compileStack = [], this.inlineStack = [], this.compileChildren(n, i), e = n.opcodes, this.i = 0, o = e.length; this.i < o; this.i++) f = e[this.i], f.opcode === "DECLARE" ? this[f.name] = f.value : this[f.opcode].apply(this, f.args); return this.createFunctionContext(u) }, nextOpcode: function () { var n = this.environment.opcodes; return n[this.i + 1] }, eat: function () { this.i = this.i + 1 }, preamble: function () { var t = [], i, n; this.isChild ? t.push("") : (i = this.namespace, n = "helpers = this.merge(helpers, " + i + ".helpers);", this.environment.usePartial && (n = n + " partials = this.merge(partials, " + i + ".partials);"), this.options.data && (n = n + " data = data || {};"), t.push(n)), this.environment.isSimple ? t.push("") : t.push(", buffer = " + this.initializeBuffer()), this.lastContext = 0, this.source = t }, createFunctionContext: function (n) { var s = this.stackVars.concat(this.registers.list), u, i, f, h, r, e, c, o; if (s.length > 0 && (this.source[1] = this.source[1] + ", " + s.join(", ")), !this.isChild) for (u in this.context.aliases) this.context.aliases.hasOwnProperty(u) && (this.source[1] = this.source[1] + ", " + u + "=" + this.context.aliases[u]); for (this.source[1] && (this.source[1] = "var " + this.source[1].substring(2) + ";"), this.isChild || (this.source[1] += "\n" + this.context.programs.join("\n") + "\n"), this.environment.isSimple || this.source.push("return buffer;"), i = this.isChild ? ["depth0", "data"] : ["Handlebars", "depth0", "helpers", "partials", "data"], f = 0, h = this.environment.depths.list.length; f < h; f++) i.push("depth" + this.environment.depths.list[f]); return r = this.mergeSource(), this.isChild || (e = t.COMPILER_REVISION, c = t.REVISION_CHANGES[e], r = "this.compilerInfo = [" + e + ",'" + c + "'];\n" + r), n ? (i.push(r), Function.apply(this, i)) : (o = "function " + (this.name || "") + "(" + i.join(",") + ") {\n  " + r + "}", t.log(t.logger.DEBUG, o + "\n\n"), o) }, mergeSource: function () { for (var u = "", t, i, r = 0, f = this.source.length; r < f; r++) i = this.source[r], i.appendToBuffer ? t = t ? t + "\n    + " + i.content : i.content : (t && (u += "buffer += " + t + ";\n  ", t = n), u += i + "\n  "); return u }, blockValue: function () { this.context.aliases.blockHelperMissing = "helpers.blockHelperMissing"; var n = ["depth0"]; this.setupParams(0, n), this.replaceStack(function (t) { return n.splice(1, 0, t), "blockHelperMissing.call(" + n.join(", ") + ")" }) }, ambiguousBlockValue: function () { var n, t; this.context.aliases.blockHelperMissing = "helpers.blockHelperMissing", n = ["depth0"], this.setupParams(0, n), t = this.topStack(), n.splice(1, 0, t), n[n.length - 1] = "options", this.source.push("if (!" + this.lastHelper + ") { " + t + " = blockHelperMissing.call(" + n.join(", ") + "); }") }, appendContent: function (n) { this.source.push(this.appendToBuffer(this.quotedString(n))) }, append: function () { this.flushInline(); var n = this.popStack(); this.source.push("if(" + n + " || " + n + " === 0) { " + this.appendToBuffer(n) + " }"), this.environment.isSimple && this.source.push("else { " + this.appendToBuffer("''") + " }") }, appendEscaped: function () { this.context.aliases.escapeExpression = "this.escapeExpression", this.source.push(this.appendToBuffer("escapeExpression(" + this.popStack() + ")")) }, getContext: function (n) { this.lastContext !== n && (this.lastContext = n) }, lookupOnContext: function (n) { this.push(this.nameLookup("depth" + this.lastContext, n, "context")) }, pushContext: function () { this.pushStackLiteral("depth" + this.lastContext) }, resolvePossibleLambda: function () { this.context.aliases.functionType = '"function"', this.replaceStack(function (n) { return "typeof " + n + " === functionType ? " + n + ".apply(depth0) : " + n }) }, lookup: function (n) { this.replaceStack(function (t) { return t + " == null || " + t + " === false ? " + t + " : " + this.nameLookup(t, n, "context") }) }, lookupData: function () { this.push("data") }, pushStringParam: function (n, t) { this.pushStackLiteral("depth" + this.lastContext), this.pushString(t), typeof n == "string" ? this.pushString(n) : this.pushStackLiteral(n) }, emptyHash: function () { this.pushStackLiteral("{}"), this.options.stringParams && (this.register("hashTypes", "{}"), this.register("hashContexts", "{}")) }, pushHash: function () { this.hash = { values: [], types: [], contexts: [] } }, popHash: function () { var t = this.hash; this.hash = n, this.options.stringParams && (this.register("hashContexts", "{" + t.contexts.join(",") + "}"), this.register("hashTypes", "{" + t.types.join(",") + "}")), this.push("{\n    " + t.values.join(",\n    ") + "\n  }") }, pushString: function (n) { this.pushStackLiteral(this.quotedString(n)) }, push: function (n) { return this.inlineStack.push(n), n }, pushLiteral: function (n) { this.pushStackLiteral(n) }, pushProgram: function (n) { n != null ? this.pushStackLiteral(this.programExpression(n)) : this.pushStackLiteral(null) }, invokeHelper: function (n, t) { this.context.aliases.helperMissing = "helpers.helperMissing"; var i = this.lastHelper = this.setupHelper(n, t, !0), r = this.nameLookup("depth" + this.lastContext, t, "context"); this.push(i.name + " || " + r), this.replaceStack(function (n) { return n + " ? " + n + ".call(" + i.callParams + ") : helperMissing.call(" + i.helperMissingParams + ")" }) }, invokeKnownHelper: function (n, t) { var i = this.setupHelper(n, t); this.push(i.name + ".call(" + i.callParams + ")") }, invokeAmbiguous: function (n, t) { this.context.aliases.functionType = '"function"', this.pushStackLiteral("{}"); var r = this.setupHelper(0, n, t), u = this.lastHelper = this.nameLookup("helpers", n, "helper"), f = this.nameLookup("depth" + this.lastContext, n, "context"), i = this.nextStack(); this.source.push("if (" + i + " = " + u + ") { " + i + " = " + i + ".call(" + r.callParams + "); }"), this.source.push("else { " + i + " = " + f + "; " + i + " = typeof " + i + " === functionType ? " + i + ".apply(depth0) : " + i + "; }") }, invokePartial: function (n) { var t = [this.nameLookup("partials", n, "partial"), "'" + n + "'", this.popStack(), "helpers", "partials"]; this.options.data && t.push("data"), this.context.aliases.self = "this", this.push("self.invokePartial(" + t.join(", ") + ")") }, assignToHash: function (n) { var u = this.popStack(), i, r, t; this.options.stringParams && (r = this.popStack(), i = this.popStack()), t = this.hash, i && t.contexts.push("'" + n + "': " + i), r && t.types.push("'" + n + "': " + r), t.values.push("'" + n + "': (" + u + ")") }, compiler: r, compileChildren: function (n, t) { for (var f = n.children, r, e, i, u = 0, o = f.length; u < o; u++) r = f[u], e = new this.compiler, i = this.matchExistingProgram(r), i == null ? (this.context.programs.push(""), i = this.context.programs.length, r.index = i, r.name = "program" + i, this.context.programs[i] = e.compile(r, t, this.context), this.context.environments[i] = r) : (r.index = i, r.name = "program" + i) }, matchExistingProgram: function (n) { for (var i, t = 0, r = this.context.environments.length; t < r; t++) if (i = this.context.environments[t], i && i.equals(n)) return t }, programExpression: function (n) { var t, e; if (this.context.aliases.self = "this", n == null) return "self.noop"; var i = this.environment.children[n], r = i.depths.list, u, f = [i.index, i.name, "data"]; for (t = 0, e = r.length; t < e; t++) u = r[t], u === 1 ? f.push("depth0") : f.push("depth" + (u - 1)); return (r.length === 0 ? "self.program(" : "self.programWithDepth(") + f.join(", ") + ")" }, register: function (n, t) { this.useRegister(n), this.source.push(n + " = " + t + ";") }, useRegister: function (n) { this.registers[n] || (this.registers[n] = !0, this.registers.list.push(n)) }, pushStackLiteral: function (n) { return this.push(new u(n)) }, pushStack: function (n) { this.flushInline(); var t = this.incrStack(); return n && this.source.push(t + " = " + n + ";"), this.compileStack.push(t), t }, replaceStack: function (n) { var r = "", e = this.isInline(), t, i, o, f; return e ? (i = this.popStack(!0), i instanceof u ? t = i.value : (o = this.stackSlot ? this.topStackName() : this.incrStack(), r = "(" + this.push(o) + " = " + i + "),", t = this.topStack())) : t = this.topStack(), f = n.call(this, t), e ? ((this.inlineStack.length || this.compileStack.length) && this.popStack(), this.push("(" + r + f + ")")) : (/^stack/.test(t) || (t = this.nextStack()), this.source.push(t + " = (" + r + f + ");")), t }, nextStack: function () { return this.pushStack() }, incrStack: function () { return this.stackSlot++, this.stackSlot > this.stackVars.length && this.stackVars.push("stack" + this.stackSlot), this.topStackName() }, topStackName: function () { return "stack" + this.stackSlot }, flushInline: function () { var i = this.inlineStack, n, r, t; if (i.length) for (this.inlineStack = [], n = 0, r = i.length; n < r; n++) t = i[n], t instanceof u ? this.compileStack.push(t) : this.pushStack(t) }, isInline: function () { return this.inlineStack.length }, popStack: function (n) { var i = this.isInline(), t = (i ? this.inlineStack : this.compileStack).pop(); return !n && t instanceof u ? t.value : (i || this.stackSlot--, t) }, topStack: function (n) { var i = this.isInline() ? this.inlineStack : this.compileStack, t = i[i.length - 1]; return !n && t instanceof u ? t.value : t }, quotedString: function (n) { return '"' + n.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"' }, setupHelper: function (n, t, i) { var r = [], u; return this.setupParams(n, r, i), u = this.nameLookup("helpers", t, "helper"), { params: r, name: u, callParams: ["depth0"].concat(r).join(", "), helperMissingParams: i && ["depth0", this.quotedString(t)].concat(r).join(", ") } }, setupParams: function (n, t, i) { var r = [], o = [], s = [], h, u, f, e; for (r.push("hash:" + this.popStack()), u = this.popStack(), f = this.popStack(), (f || u) && (f || (this.context.aliases.self = "this", f = "self.noop"), u || (this.context.aliases.self = "this", u = "self.noop"), r.push("inverse:" + u), r.push("fn:" + f)), e = 0; e < n; e++) h = this.popStack(), t.push(h), this.options.stringParams && (s.push(this.popStack()), o.push(this.popStack())); return this.options.stringParams && (r.push("contexts:[" + o.join(",") + "]"), r.push("types:[" + s.join(",") + "]"), r.push("hashContexts:hashContexts"), r.push("hashTypes:hashTypes")), this.options.data && r.push("data:data"), r = "{" + r.join(",") + "}", i ? (this.register("options", r), t.push("options")) : t.push(r), t.join(", ") } }, h = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield".split(" "), a = r.RESERVED_WORDS = {}, s = 0, v = h.length; s < v; s++) a[h[s]] = !0; r.isValidJavaScriptVariableName = function (n) { return !r.RESERVED_WORDS[n] && /^[a-zA-Z_$][0-9a-zA-Z_$]+$/.test(n) ? !0 : !1 }, t.VM = { template: function (n) { var i = { escapeExpression: t.Utils.escapeExpression, invokePartial: t.VM.invokePartial, programs: [], program: function (n, i, r) { var u = this.programs[n]; return r ? u = t.VM.program(n, i, r) : u || (u = this.programs[n] = t.VM.program(n, i)), u }, merge: function (n, i) { var r = n || i; return n && i && (r = {}, t.Utils.extend(r, i), t.Utils.extend(r, n)), r }, programWithDepth: t.VM.programWithDepth, noop: t.VM.noop, compilerInfo: null }; return function (r, u) { var s, h; u = u || {}; var c = n.call(i, t, r, u.helpers, u.partials, u.data), o = i.compilerInfo || [], f = o[0] || 1, e = t.COMPILER_REVISION; if (f !== e) if (f < e) { s = t.REVISION_CHANGES[e], h = t.REVISION_CHANGES[f]; throw "Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + s + ") or downgrade your runtime to an older version (" + h + ")."; } else throw "Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + o[1] + ")."; return c } }, programWithDepth: function (n, t, i) { var u = Array.prototype.slice.call(arguments, 3), r = function (n, r) { return r = r || {}, t.apply(this, [n, r.data || i].concat(u)) }; return r.program = n, r.depth = u.length, r }, program: function (n, t, i) { var r = function (n, r) { return r = r || {}, t(n, r.data || i) }; return r.program = n, r.depth = 0, r }, noop: function () { return "" }, invokePartial: function (i, r, u, f, e, o) { var s = { helpers: f, partials: e, data: o }; if (i === n) throw new t.Exception("The partial " + r + " could not be found"); else { if (i instanceof Function) return i(u, s); if (t.compile) return e[r] = t.compile(i, { data: o !== n }), e[r](u, s); throw new t.Exception("The partial " + r + " could not be compiled when running in runtime-only mode"); } } }, t.template = t.VM.template, this.Handlebars = t }).call(this);